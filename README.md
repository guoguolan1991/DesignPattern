# DesignPattern
# 创建型设计模式：
#### Singleton Pattern（单例模式）
#### Prototype Pattern（原型模式）
用原型实例指定创建对象的种类，并通过拷贝这些原型创建新的对象。
#### Factory Method Pattern（工厂方法模式）
#### Abstract Factory Pattern（抽象工厂模式）
#### Builder Pattern（建造者模式）
# 结构型设计模式：
#### Adapter Pattern（适配器模式）
将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以在一起工作。
#### Bridge Pattern（桥接模式）
#### Composite Pattern（组合模式）
组合模式的环境为：
    在设计中想表示对象的“部分－整体”层次结构；希望用户忽略组合对象与单个对象的不同，统一地使用组合结构中的所有对象。
看下组合模式的组成。
1) 抽象构件角色Component：它为组合中的对象声明接口，也可以为共有接口实现缺省行为。
2) 树叶构件角色Leaf：在组合中表示叶节点对象——没有子节点，实现抽象构件角色声明的接口。
3) 树枝构件角色Composite：在组合中表示分支节点对象——有子节点，实现抽象构件角色声明的接口；存储子部件。
#### Decorator Pattern（装饰者模式）
#### Façade Pattern（外观模式）
#### Flyweight Pattern（[享元模式](http://blog.csdn.net/tanggao1314/article/details/50615033)）
Flyweight在拳击比赛中指最轻量级，即“蝇量级”或“雨量级”，这里选择使用“享元模式”的意译，是因为这样更能反映模式的用意。
享元模式是对象的结构模式。享元模式以共享的方式高效地支持大量的细粒度对象。 
也就是说在一个系统中如果有多个相同的对象，那么只共享一份就可以了，不必每个都去实例化一个对象。
#### Proxy Pattern（代理模式）
代理模式是常用的结构型设计模式之一，当无法直接访问某个对象或访问某个对象存在困难时可以通过一个代理对象来间接访问，为了保证客户端使用的透明性，
所访问的真实对象与代理对象需要实现相同的接口。

远程代理(Remote Proxy)

给一个位于不同的地址空间的对象提供一个本地的代理对象，这个不同的地址空间可以是在同一台主机中，也可是在另一台主机中，远程代理又称为大使(Ambassador)。

虚拟代理(Virtual Proxy)

如果需要创建一个资源消耗较大的对象，先创建一个消耗相对较小的对象来表示，真实对象只在需要时才会被真正创建。

保护代理(Protect Proxy)

控制对一个对象的访问，可以给不同的用户提供不同级别的使用权限。

缓冲代理(Cache Proxy)

为某一个目标操作的结果提供临时的存储空间，以便多个客户端可以共享这些结果。

智能引用代理(Smart Reference Proxy)

当一个对象被引用时，提供一些额外的操作，例如将对象被调用的次数记录下来等。
# 行为型设计模式：
#### Chain of Responsibility Pattern（职责链模式）
#### Command Pattern（命令模式）
#### Interpreter Pattern（解释器模式）
#### Iterator Pattern（迭代器模式）
#### Mediator Pattern（中介者模式）
用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，
从而使其耦合松散，而且可以独立地改变它们之间的交互。
#### Memento Pattern（备忘录模式）
#### Observer Pattern（观察者模式）
#### State Pattern（状态模式）
#### Strategy Pattern（策略模式）
策略模式属于对象的行为模式。其用意是针对一组算法，将每一个算法封装到具有共同接口的独立的类中，从而使得它们可以相互替换。策略模式使得算法可以在不影响到客户端的情况下发生变化。
#### Template Method Pattern（[模板方法模式](http://www.cnblogs.com/java-my-life/archive/2012/05/14/2495235.html)）
模板方法模式是类的行为模式。准备一个抽象类，将部分逻辑以具体方法以及具体构造函数的形式实现，然后声明一些抽象方法来迫使子类实现剩余的逻辑。不同的子类可以以不同的方式实现这些
抽象方法，从而对剩余的逻辑有不同的实现。这就是模板方法模式的用意。
模板方法中的方法可以分为两大类：模板方法和基本方法。

　　模板方法
　　一个模板方法是定义在抽象类中的，把基本操作方法组合在一起形成一个总算法或一个总行为的方法。

　　一个抽象类可以有任意多个模板方法，而不限于一个。每一个模板方法都可以调用任意多个具体方法。

　　基本方法
　　基本方法又可以分为三种：抽象方法(Abstract Method)、具体方法(Concrete Method)和钩子方法(Hook Method)。

　　●　　抽象方法：一个抽象方法由抽象类声明，由具体子类实现。在Java语言里抽象方法以abstract关键字标示。

　　●　　具体方法：一个具体方法由抽象类声明并实现，而子类并不实现或置换。

　　●　　钩子方法：一个钩子方法由抽象类声明并实现，而子类会加以扩展。通常抽象类给出的实现是一个空实现，作为方法的默认实现。
#### Visitor Pattern（[访问者模式](http://www.cnblogs.com/java-my-life/archive/2012/06/14/2545381.html)）
访问者模式是对象的行为模式。访问者模式的目的是封装一些施加于某种数据结构元素之上的操作。一旦这些操作需要修改的话，
接受这个操作的数据结构则可以保持不变。

模式优缺点
   优点
      1、使得新增新的访问操作变得更加简单。
      2、能够使得用户在不修改现有类的层次结构下，定义该类层次结构的操作。
      3、将有关元素对象的访问行为集中到一个访问者对象中，而不是分散搞一个个的元素类中。
   缺点
      1、增加新的元素类很困难。在访问者模式中，每增加一个新的元素类都意味着要在抽象访问者角色中增加一个新的抽象操作，并在每一个具体访问者类中增加相应的具体操作，违背了“开闭原则”的要求。
      2、破坏封装。当采用访问者模式的时候，就会打破组合类的封装。
      3、比较难理解。貌似是最难的设计模式了。
 模式适用场景
       1、对象结构中对象对应的类很少改变，但经常需要在此对象结构上定义新的操作。
       2、需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作“污染”这些对象的类，也不希望在增加新操作时修改这些类。
  模式总结
       1、访问者模式封装了对象结构元素之上的操作，使得新增元素的操作变得非常简单。所以它比较适用于那么对象结构很少变化的类。
       2、访问者模式中对象结构存储了不同类型的元素对象，以供不同访问者访问。
